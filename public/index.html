<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Semantic Word Cloud with Word Embeddings</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            min-height: 100vh;
            min-height: 100dvh; /* Dynamic viewport height for mobile */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Mobile viewport fix */
        @supports (-webkit-touch-callout: none) {
            body {
                min-height: -webkit-fill-available;
            }
        }

        /* Header */
        .header {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }

        @media (max-width: 768px) {
            .header {
                padding: 0.75rem 1rem;
                flex-wrap: wrap;
            }

            .header h1 {
                font-size: 1.2rem !important;
            }

            .stats {
                gap: 1rem !important;
            }

            .stat-value {
                font-size: 1.2rem !important;
            }

            .stat-label {
                font-size: 0.7rem !important;
            }
        }

        .header h1 {
            color: white;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .stats {
            display: flex;
            gap: 2rem;
            color: white;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        /* Main container */
        .container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
            min-height: 0; /* Allow flex shrinking */
        }

        /* Controls panel */
        .controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 12px;
            display: flex;
            gap: 0.5rem;
            z-index: 100;
        }

        @media (max-width: 768px) {
            .controls {
                top: auto;
                bottom: 8rem;
                bottom: calc(8rem + env(safe-area-inset-bottom));
                right: 0.5rem;
                padding: 0.5rem;
                flex-direction: column;
            }
        }

        .zoom-btn {
            width: 36px;
            height: 36px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(50, 50, 50, 0.8);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: rgba(80, 80, 80, 0.9);
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .zoom-btn {
                width: 40px;
                height: 40px;
            }
        }

        /* Word input panel */
        .input-panel {
            position: absolute;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px);
            padding: 1.5rem;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 100;
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        @media (max-width: 768px) {
            .input-panel {
                bottom: 1rem;
                bottom: max(1rem, env(safe-area-inset-bottom));
                left: 1rem;
                right: 1rem;
                transform: none;
                padding: 1rem;
                flex-direction: row;
                width: auto;
            }

            .input-panel input {
                width: 100% !important;
                flex: 1;
            }

            .input-panel button {
                flex-shrink: 0;
                padding: 0.8rem 1.5rem;
            }
        }

        .input-panel input {
            padding: 0.8rem 1.2rem;
            border: 2px solid #555;
            background: rgba(50, 50, 50, 0.8);
            color: white;
            border-radius: 12px;
            font-size: 1rem;
            width: 300px;
            transition: all 0.3s ease;
        }

        .input-panel input::placeholder {
            color: #999;
        }

        .input-panel input:focus {
            outline: none;
            border-color: #888;
            box-shadow: 0 0 0 3px rgba(136, 136, 136, 0.2);
        }

        .input-panel button {
            padding: 0.8rem 2rem;
            background: linear-gradient(135deg, #3a3a3a 0%, #505050 100%);
            color: white;
            border: 1px solid #666;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .input-panel button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(100, 100, 100, 0.4);
            background: linear-gradient(135deg, #505050 0%, #6a6a6a 100%);
        }

        .input-panel button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* SVG container */
        #wordCloud {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #wordCloud:active {
            cursor: grabbing;
        }

        /* Word nodes */
        .word-node {
            cursor: pointer;
        }

        .word-group {
            transition: filter 0.3s ease;
        }

        .word-group:hover {
            filter: brightness(1.3) drop-shadow(0 0 25px rgba(255, 255, 255, 0.8));
        }

        .word-circle {
            fill-opacity: 0.9;
            stroke: white;
            stroke-width: 2;
        }

        .word-text {
            fill: white;
            font-weight: 600;
            text-anchor: middle;
            user-select: none;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        /* Links between words */
        .word-link {
            stroke-opacity: 0.6;
            stroke-linecap: round;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            padding: 0.8rem 1.2rem;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            border-radius: 8px;
            font-size: 0.9rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 200;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip strong {
            color: #64b5f6;
            font-size: 1.1rem;
        }

        /* Animation for new words */
        @keyframes pulse {
            0% {
                r: 0;
                opacity: 1;
            }
            100% {
                r: 80;
                opacity: 0;
            }
        }

        .pulse-ring {
            fill: none;
            stroke: white;
            stroke-width: 3;
            animation: pulse 1.5s ease-out;
        }

        /* Instructions overlay */
        .instructions {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 12px;
            color: white;
            font-size: 0.9rem;
            max-width: 250px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .instructions.hidden {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }

        .instructions h3 {
            margin-bottom: 0.5rem;
            color: #c5c5c5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .instructions ul {
            list-style: none;
            padding: 0;
        }

        .instructions li {
            margin: 0.3rem 0;
            padding-left: 1rem;
        }

        .instructions li:before {
            content: "→ ";
            margin-left: -1rem;
            margin-right: 0.3rem;
            color: #888;
        }

        .toggle-instructions-btn {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            font-size: 0.9rem;
            z-index: 99;
            transition: all 0.3s ease;
        }

        .toggle-instructions-btn:hover {
            background: rgba(50, 50, 50, 0.9);
        }

        @media (max-width: 768px) {
            .instructions {
                max-width: calc(100vw - 2rem);
                font-size: 0.8rem;
            }

            .toggle-instructions-btn {
                font-size: 0.8rem;
                padding: 0.4rem 0.8rem;
            }
        }

        .loading-indicator {
            display: none;
            color: #999;
            font-size: 0.9rem;
            margin-left: 1rem;
        }

        .loading-indicator.show {
            display: inline-block;
        }

        /* Semantic similarity legend */
        .legend {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 12px;
            color: white;
            font-size: 0.8rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .legend-title {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #c5c5c5;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0.3rem 0;
        }

        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 0.5rem;
            border-radius: 1px;
        }

        @media (max-width: 768px) {
            .legend {
                display: none;
            }
        }

        /* Color picker context menu */
        .color-picker-menu {
            position: absolute;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 12px;
            display: none;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .color-picker-menu.show {
            display: block;
        }

        .color-picker-title {
            color: #c5c5c5;
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .color-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .color-option {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .color-option:hover {
            transform: scale(1.1);
            border-color: white;
        }

        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        @media (max-width: 768px) {
            .color-option {
                width: 45px;
                height: 45px;
            }
        }
    </style>
</head>
<body>
    <!-- Header with stats -->
    <div class="header">
        <h1>Romeo & Juliet Word Cloud</h1>
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="wordCount">0</div>
                <div class="stat-label">Words</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="uniqueCount">0</div>
                <div class="stat-label">Unique</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="connectionCount">0</div>
                <div class="stat-label">Connections</div>
            </div>
        </div>
    </div>

    <!-- Main container -->
    <div class="container">
        <!-- Toggle Instructions Button -->
        <button class="toggle-instructions-btn" onclick="toggleInstructions()">ℹ️ Info</button>

        <!-- Instructions -->
        <div class="instructions" id="instructions">
            <h3>
                How to use:
                <span style="cursor: pointer; opacity: 0.7;" onclick="toggleInstructions()">✕</span>
            </h3>
            <ul>
                <li>Type a word and press Enter</li>
                <li>Similar words connect (max 5 per node)</li>
                <li>Drag to pan, scroll to zoom</li>
                <li>Click and drag nodes to reorganize</li>
                <li>Right-click or double-click to change color</li>
                <li>Mobile: Long press to change color</li>
            </ul>
        </div>

        <!-- Zoom controls -->
        <div class="controls">
            <button class="zoom-btn" onclick="zoomIn()" title="Zoom In">+</button>
            <button class="zoom-btn" onclick="zoomOut()" title="Zoom Out">−</button>
            <button class="zoom-btn" onclick="resetZoom()" title="Reset View">⟲</button>
        </div>

        <!-- Legend -->
        <div class="legend">
            <div class="legend-title">Connection Strength</div>
            <div class="legend-item">
                <div class="legend-line" style="background: rgba(100, 181, 246, 1); height: 4px;"></div>
                <span>Strong (>0.7)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: rgba(100, 181, 246, 0.6); height: 2px;"></div>
                <span>Medium (0.5-0.7)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: rgba(100, 181, 246, 0.3); height: 1px;"></div>
                <span>Weak (0.3-0.5)</span>
            </div>
        </div>

        <!-- SVG for word cloud -->
        <svg id="wordCloud"></svg>

        <!-- Input panel -->
        <div class="input-panel">
            <input type="text" id="wordInput" placeholder="Enter a word or concept..." autofocus>
            <button id="addButton" onclick="addWord()">Add Word</button>
            <span class="loading-indicator" id="loadingIndicator">Loading embeddings...</span>
        </div>

        <!-- Tooltip -->
        <div class="tooltip" id="tooltip"></div>

        <!-- Color Picker Menu -->
        <div class="color-picker-menu" id="colorPickerMenu">
            <div class="color-picker-title">Choose a color:</div>
            <div class="color-options" id="colorOptions"></div>
        </div>
    </div>

    <!-- Socket.IO client -->
    <script src="/socket.io/socket.io.js"></script>

    <!-- D3.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

    <!-- TensorFlow.js for word embeddings -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/universal-sentence-encoder@1.3.3/dist/universal-sentence-encoder.min.js"></script>

    <script>
        // Socket.IO connection
        const socket = io();
        let isInitialized = false;

        // VS Code dark theme inspired color palette (6 colors)
        const pastelColors = [
            '#F48771', // coral/salmon (like VS Code error/red)
            '#89D185', // vibrant green (like VS Code string)
            '#4EC9B0', // cyan/teal (like VS Code type)
            '#bd9b2b', // golden yellow (like VS Code function)
            '#5e28b5', // purple/magenta (like VS Code keyword)
            '#e622df'  // orange/brown (like VS Code number)
        ];

        // Word cloud data
        let words = new Map(); // Map to store word -> {text, count, x, y, embedding, color}
        let links = []; // Array of {source, target, strength}
        let model = null; // Universal Sentence Encoder model
        let longPressTimer = null;
        let selectedWordForColor = null;
        
        // D3 setup
        const svg = d3.select("#wordCloud");
        const width = window.innerWidth;
        const height = window.innerHeight - 80;
        
        svg.attr("viewBox", [0, 0, width, height]);
        
        // Create main group for zoom/pan
        const mainGroup = svg.append("g");
        
        // Create groups for links and nodes
        const linkGroup = mainGroup.append("g").attr("class", "links");
        const nodeGroup = mainGroup.append("g").attr("class", "nodes");
        
        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                mainGroup.attr("transform", event.transform);
            });
        
        svg.call(zoom);
        
        // Custom repulsion force based on semantic dissimilarity
        function repulsionForce() {
            let nodes;

            function force(alpha) {
                if (!nodes) return;

                const wordsArray = Array.from(words.values());

                for (let i = 0; i < wordsArray.length; i++) {
                    const nodeA = wordsArray[i];
                    if (!nodeA.embedding) continue;

                    for (let j = i + 1; j < wordsArray.length; j++) {
                        const nodeB = wordsArray[j];
                        if (!nodeB.embedding) continue;

                        // Calculate similarity
                        let similarity = 0;
                        let dotProduct = 0;
                        let normA = 0;
                        let normB = 0;

                        for (let k = 0; k < nodeA.embedding.length; k++) {
                            dotProduct += nodeA.embedding[k] * nodeB.embedding[k];
                            normA += nodeA.embedding[k] * nodeA.embedding[k];
                            normB += nodeB.embedding[k] * nodeB.embedding[k];
                        }

                        normA = Math.sqrt(normA);
                        normB = Math.sqrt(normB);

                        if (normA !== 0 && normB !== 0) {
                            similarity = dotProduct / (normA * normB);
                        }

                        // Only apply repulsion for dissimilar nodes (low similarity)
                        if (similarity < 0.3) {
                            const dx = nodeB.x - nodeA.x;
                            const dy = nodeB.y - nodeA.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance > 0 && distance < 400) {
                                // Repulsion strength based on dissimilarity (inverse of similarity)
                                const dissimilarity = 1 - similarity;
                                const repulsionStrength = (dissimilarity * 100) / (distance * distance);

                                const forceX = (dx / distance) * repulsionStrength * alpha;
                                const forceY = (dy / distance) * repulsionStrength * alpha;

                                nodeA.vx -= forceX;
                                nodeA.vy -= forceY;
                                nodeB.vx += forceX;
                                nodeB.vy += forceY;
                            }
                        }
                    }
                }
            }

            force.initialize = function(_) {
                nodes = _;
            };

            return force;
        }

        // Force simulation with stronger center gravity
        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink()
                .id(d => d.text)
                .distance(d => 150 * (1 - d.strength)) // Closer for stronger connections
                .strength(d => d.strength * 1.5)) // Stronger pull for similar words
            .force("charge", d3.forceManyBody()
                .strength(-200)
                .distanceMax(300))
            .force("repulsion", repulsionForce()) // Custom semantic repulsion
            .force("center", d3.forceCenter(width / 2, height / 2).strength(0.1))
            .force("collision", d3.forceCollide().radius(d => d.radius + 5))
            .force("x", d3.forceX(width / 2).strength(0.05)) // Keep nodes centered
            .force("y", d3.forceY(height / 2).strength(0.05)); // Keep nodes centered
        
        // Helper function to get node color
        function getNodeColor(wordData, index) {
            if (wordData.color) {
                return wordData.color;
            }
            return pastelColors[index % pastelColors.length];
        }

        // Color scales
        const linkColorScale = d3.scaleLinear()
            .domain([0.3, 0.5, 0.7, 1.0])
            .range(["rgba(150, 150, 150, 0.3)", "rgba(180, 180, 180, 0.5)", "rgba(200, 200, 200, 0.7)", "rgba(220, 220, 220, 1)"]);

        const linkWidthScale = d3.scaleLinear()
            .domain([0.3, 1.0])
            .range([1, 5]);

        // Initialize color picker
        function initializeColorPicker() {
            const colorOptions = document.getElementById('colorOptions');
            pastelColors.forEach(color => {
                const option = document.createElement('div');
                option.className = 'color-option';
                option.style.backgroundColor = color;
                option.onclick = () => selectColor(color);
                colorOptions.appendChild(option);
            });
        }

        // Toggle instructions
        function toggleInstructions() {
            const instructions = document.getElementById('instructions');
            instructions.classList.toggle('hidden');
        }

        // Show color picker menu
        function showColorPicker(event, wordData) {
            const menu = document.getElementById('colorPickerMenu');
            selectedWordForColor = wordData;

            // First show the menu to get its dimensions
            menu.classList.add('show');

            // Position the menu
            let x = event.pageX || (event.touches && event.touches[0].pageX);
            let y = event.pageY || (event.touches && event.touches[0].pageY);

            // Get menu dimensions
            const menuRect = menu.getBoundingClientRect();
            const menuWidth = menuRect.width;
            const menuHeight = menuRect.height;

            // Adjust position to keep menu on screen
            if (x + menuWidth + 10 > window.innerWidth) {
                x = window.innerWidth - menuWidth - 10;
            }
            if (y - menuHeight < 0) {
                y = menuHeight + 10;
            }
            if (x < 10) {
                x = 10;
            }

            menu.style.left = `${x + 10}px`;
            menu.style.top = `${y - menuHeight - 10}px`;

            // Highlight current color
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('selected');
                if (wordData.color && option.style.backgroundColor === rgbToHex(wordData.color)) {
                    option.classList.add('selected');
                }
            });
        }

        // Hide color picker
        function hideColorPicker() {
            const menu = document.getElementById('colorPickerMenu');
            menu.classList.remove('show');
            selectedWordForColor = null;
        }

        // Select color
        function selectColor(color) {
            if (selectedWordForColor) {
                selectedWordForColor.color = color;

                // Broadcast color change to server
                socket.emit('changeColor', {
                    word: selectedWordForColor.text,
                    color: color
                });

                updateVisualization();
                hideColorPicker();
            }
        }

        // Convert rgb to hex helper
        function rgbToHex(rgb) {
            if (rgb.startsWith('#')) return rgb.toLowerCase();
            const values = rgb.match(/\d+/g);
            if (!values) return rgb;
            return '#' + values.slice(0, 3).map(x => {
                const hex = parseInt(x).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('').toUpperCase();
        }

        // Close color picker when clicking outside
        document.addEventListener('click', (event) => {
            const menu = document.getElementById('colorPickerMenu');
            if (menu.classList.contains('show') && !menu.contains(event.target)) {
                hideColorPicker();
            }
        });
        
        // Load the Universal Sentence Encoder model
        async function loadModel() {
            const loadingIndicator = document.getElementById('loadingIndicator');
            const addButton = document.getElementById('addButton');

            loadingIndicator.classList.add('show');
            addButton.disabled = true;

            try {
                model = await use.load();
                console.log('Universal Sentence Encoder loaded successfully');
            } catch (error) {
                console.error('Error loading model:', error);
                alert('Failed to load word embedding model.');
            } finally {
                loadingIndicator.classList.remove('show');
                addButton.disabled = false;
            }
        }
        
        // Calculate semantic similarity using embeddings
        async function calculateSemanticSimilarity(embedding1, embedding2) {
            if (!embedding1 || !embedding2) return 0;
            
            // Cosine similarity
            let dotProduct = 0;
            let norm1 = 0;
            let norm2 = 0;
            
            for (let i = 0; i < embedding1.length; i++) {
                dotProduct += embedding1[i] * embedding2[i];
                norm1 += embedding1[i] * embedding1[i];
                norm2 += embedding2[i] * embedding2[i];
            }
            
            norm1 = Math.sqrt(norm1);
            norm2 = Math.sqrt(norm2);
            
            if (norm1 === 0 || norm2 === 0) return 0;
            
            return dotProduct / (norm1 * norm2);
        }
        
        // Get word embedding
        async function getEmbedding(text) {
            if (!model) return null;

            try {
                const embeddings = await model.embed([text]);
                const embeddingArray = await embeddings.array();
                embeddings.dispose(); // Clean up tensor
                return embeddingArray[0];
            } catch (error) {
                console.error('Error getting embedding:', error);
                return null;
            }
        }
        
        // Add word function
        async function addWord() {
            const input = document.getElementById("wordInput");
            const word = input.value.trim().toLowerCase();

            if (word) {
                const addButton = document.getElementById('addButton');
                addButton.disabled = true;

                // Get embedding for the new word
                const embedding = await getEmbedding(word);

                // Send to server via Socket.IO
                socket.emit('addWord', { word: word, embedding: embedding });

                // Clear input
                input.value = "";
                addButton.disabled = false;
            }
        }
        
        // Socket.IO event handlers
        socket.on('initialize', (data) => {
            console.log('Received initial data:', data);

            // Load existing words
            data.words.forEach(wordData => {
                words.set(wordData.text, {
                    text: wordData.text,
                    count: wordData.count,
                    radius: Math.min(15 + wordData.count * 4, 50),
                    x: width / 2 + (Math.random() - 0.5) * 200,
                    y: height / 2 + (Math.random() - 0.5) * 200,
                    embedding: wordData.embedding,
                    color: wordData.color || null
                });
            });

            // Load existing connections and convert string references to proper format
            links = (data.connections || []).map(link => {
                const sourceText = link.source.text || link.source;
                const targetText = link.target.text || link.target;
                return {
                    source: sourceText,
                    target: targetText,
                    strength: link.strength
                };
            });

            // Update visualization
            updateVisualization();
            updateStats();
            isInitialized = true;
        });

        socket.on('wordAdded', async (data) => {
            console.log('Word added:', data);

            // Update or add word
            if (words.has(data.word)) {
                const wordData = words.get(data.word);
                wordData.count = data.count;
                wordData.radius = Math.min(15 + wordData.count * 4, 50);
            } else {
                words.set(data.word, {
                    text: data.word,
                    count: data.count,
                    radius: Math.min(15 + data.count * 4, 50),
                    x: width / 2 + (Math.random() - 0.5) * 50,
                    y: height / 2 + (Math.random() - 0.5) * 50,
                    embedding: data.embedding,
                    color: data.color || null
                });

                // Update connections with semantic similarity
                await updateSemanticConnections(data.word);
            }

            // Update visualization
            updateVisualization();

            // Update stats
            updateStats();

            // Add pulse effect
            addPulseEffect(words.get(data.word));
        });

        socket.on('colorChanged', (data) => {
            console.log('Color changed:', data);
            if (words.has(data.word)) {
                const wordData = words.get(data.word);
                wordData.color = data.color;
                updateVisualization();
            }
        });

        socket.on('connectionsUpdated', (updatedConnections) => {
            // Normalize connections to use string references
            links = updatedConnections.map(link => {
                const sourceText = link.source.text || link.source;
                const targetText = link.target.text || link.target;
                return {
                    source: sourceText,
                    target: targetText,
                    strength: link.strength
                };
            });
            updateVisualization();
            updateStats();
        });

        // Update connections based on semantic similarity
        async function updateSemanticConnections(newWord) {
            const newWordData = words.get(newWord);
            if (!newWordData.embedding) return;

            // Calculate similarities between new word and all existing words
            const similarities = [];
            for (const [existingWord, existingData] of words) {
                if (existingWord !== newWord && existingData.embedding) {
                    const similarity = await calculateSemanticSimilarity(
                        newWordData.embedding,
                        existingData.embedding
                    );

                    // Only consider meaningful similarity
                    if (similarity > 0.3) {
                        similarities.push({
                            word: existingWord,
                            similarity: similarity
                        });
                    }
                }
            }

            // Sort by similarity and take top 5 for the new word
            similarities.sort((a, b) => b.similarity - a.similarity);
            const top5ForNewWord = similarities.slice(0, 5);

            // Track which nodes were affected (new word + its connections)
            const affectedNodes = new Set([newWord]);

            // Add initial connections for the new word with decreasing strength
            top5ForNewWord.forEach((item, index) => {
                const strengthMultiplier = [1.0, 0.8, 0.6, 0.5, 0.4][index];

                links.push({
                    source: newWord,
                    target: item.word,
                    strength: item.similarity * strengthMultiplier
                });

                // Mark this node as affected (needs recalculation)
                affectedNodes.add(item.word);
            });

            // Recalculate connections for all affected nodes
            await recalculateNodeConnections(affectedNodes);

            // Normalize links to string format before broadcasting
            const normalizedLinks = links.map(link => ({
                source: link.source.text || link.source,
                target: link.target.text || link.target,
                strength: link.strength
            }));

            // Broadcast updated connections to server
            socket.emit('updateConnections', normalizedLinks);
        }

        // Recalculate and enforce top 3 connections for specific nodes
        async function recalculateNodeConnections(nodesToRecalculate) {
            // Build a map of all current connections per node
            const nodeConnectionsMap = new Map();

            links.forEach(link => {
                const sourceText = link.source.text || link.source;
                const targetText = link.target.text || link.target;

                if (!nodeConnectionsMap.has(sourceText)) nodeConnectionsMap.set(sourceText, []);
                if (!nodeConnectionsMap.has(targetText)) nodeConnectionsMap.set(targetText, []);

                nodeConnectionsMap.get(sourceText).push({
                    link: link,
                    otherNode: targetText,
                    strength: link.strength
                });
                nodeConnectionsMap.get(targetText).push({
                    link: link,
                    otherNode: sourceText,
                    strength: link.strength
                });
            });

            // For each affected node, keep only top 3 strongest connections
            const linksToKeep = new Set();

            for (const node of nodesToRecalculate) {
                const nodeConnections = nodeConnectionsMap.get(node) || [];

                // Sort by strength and take top 5
                const top5 = nodeConnections
                    .sort((a, b) => b.strength - a.strength)
                    .slice(0, 5);

                // Mark these links to keep
                top5.forEach(conn => linksToKeep.add(conn.link));
            }

            // Also keep links for nodes that weren't affected
            links.forEach(link => {
                const sourceText = link.source.text || link.source;
                const targetText = link.target.text || link.target;

                // If neither node was affected, keep this link
                if (!nodesToRecalculate.has(sourceText) && !nodesToRecalculate.has(targetText)) {
                    linksToKeep.add(link);
                }
            });

            // Update links array
            links = Array.from(linksToKeep);
        }
        
        // Update visualization
        function updateVisualization() {
            const wordsArray = Array.from(words.values());

            // Preprocess links to convert string references to node objects
            // Create a cache map for faster lookups
            const nodeCache = new Map(wordsArray.map(node => [node.text, node]));

            for (const link of links) {
                if (typeof link.source === 'string') {
                    link.source = nodeCache.get(link.source) || link.source;
                }
                if (typeof link.target === 'string') {
                    link.target = nodeCache.get(link.target) || link.target;
                }
            }

            // Update links
            const link = linkGroup.selectAll(".word-link")
                .data(links, d => `${d.source.text || d.source}-${d.target.text || d.target}`);

            link.enter()
                .append("line")
                .attr("class", "word-link")
                .style("stroke", d => linkColorScale(d.strength))
                .style("stroke-width", d => linkWidthScale(d.strength));

            // Update existing links
            link.style("stroke", d => linkColorScale(d.strength))
                .style("stroke-width", d => linkWidthScale(d.strength));

            link.exit().remove();
            
            // Update nodes
            const node = nodeGroup.selectAll(".word-group")
                .data(wordsArray, d => d.text);
            
            const nodeEnter = node.enter()
                .append("g")
                .attr("class", "word-group")
                .call(drag(simulation));
            
            nodeEnter.append("circle")
                .attr("class", "word-circle")
                .attr("r", d => d.radius)
                .attr("fill", (d, i) => getNodeColor(d, i));
            
            nodeEnter.append("text")
                .attr("class", "word-text")
                .attr("dy", ".35em")
                .text(d => d.text)
                .style("font-size", d => `${Math.max(Math.min(d.radius / 2.5, 20), 10)}px`);
            
            // Update existing nodes
            node.select("circle")
                .transition()
                .duration(500)
                .attr("r", d => d.radius)
                .attr("fill", (d, i) => getNodeColor(d, i));

            node.select("text")
                .transition()
                .duration(500)
                .style("font-size", d => `${Math.max(Math.min(d.radius / 2.5, 20), 10)}px`);

            node.exit().remove();

            // Add hover events
            nodeGroup.selectAll(".word-group")
                .on("mouseenter", function(event, d) {
                    showTooltip(event, d);
                    highlightConnections(d);
                })
                .on("mouseleave", function() {
                    hideTooltip();
                    resetHighlight();
                })
                .on("contextmenu", function(event, d) {
                    event.preventDefault();
                    showColorPicker(event, d);
                })
                .on("dblclick", function(event, d) {
                    event.preventDefault();
                    showColorPicker(event, d);
                });

            // Add long-press for mobile (on circles specifically to avoid drag conflict)
            nodeGroup.selectAll(".word-circle")
                .on("touchstart", function(event, d) {
                    const parentData = d3.select(this.parentNode).datum();
                    longPressTimer = setTimeout(() => {
                        showColorPicker(event, parentData);
                    }, 600);
                })
                .on("touchend touchcancel touchmove", function() {
                    if (longPressTimer) {
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                    }
                });
            
            // Update simulation
            simulation.nodes(wordsArray);
            simulation.force("link").links(links);
            simulation.alpha(0.5).restart();
            
            simulation.on("tick", () => {
                linkGroup.selectAll(".word-link")
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
                
                nodeGroup.selectAll(".word-group")
                    .attr("transform", d => `translate(${d.x},${d.y})`);
            });
        }
        
        // Highlight connections on hover
        function highlightConnections(hoveredNode) {
            // Dim all nodes and links
            nodeGroup.selectAll(".word-group").style("opacity", 0.3);
            linkGroup.selectAll(".word-link").style("opacity", 0.1);
            
            // Highlight hovered node
            nodeGroup.selectAll(".word-group")
                .filter(d => d.text === hoveredNode.text)
                .style("opacity", 1);
            
            // Highlight connected nodes and links
            links.forEach(link => {
                const sourceText = link.source.text || link.source;
                const targetText = link.target.text || link.target;
                
                if (sourceText === hoveredNode.text || targetText === hoveredNode.text) {
                    linkGroup.selectAll(".word-link")
                        .filter(d => {
                            const linkSourceText = d.source.text || d.source;
                            const linkTargetText = d.target.text || d.target;
                            return (linkSourceText === sourceText && linkTargetText === targetText) ||
                                   (linkSourceText === targetText && linkTargetText === sourceText);
                        })
                        .style("opacity", 1)
                        .style("stroke-width", d => linkWidthScale(d.strength) * 1.5);
                    
                    const connectedNode = sourceText === hoveredNode.text ? targetText : sourceText;
                    nodeGroup.selectAll(".word-group")
                        .filter(d => d.text === connectedNode)
                        .style("opacity", 1);
                }
            });
        }
        
        function resetHighlight() {
            nodeGroup.selectAll(".word-group").style("opacity", 1);
            linkGroup.selectAll(".word-link")
                .style("opacity", 0.6)
                .style("stroke-width", d => linkWidthScale(d.strength));
        }
        
        // Drag functionality
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }
        
        // Zoom controls
        function zoomIn() {
            svg.transition().duration(300).call(zoom.scaleBy, 1.3);
        }
        
        function zoomOut() {
            svg.transition().duration(300).call(zoom.scaleBy, 0.7);
        }
        
        function resetZoom() {
            svg.transition().duration(300).call(zoom.transform, d3.zoomIdentity);
        }
        
        // Tooltip functions
        function showTooltip(event, d) {
            const tooltip = document.getElementById("tooltip");

            // Calculate connected words
            const connections = links.filter(l =>
                (l.source.text === d.text || l.target.text === d.text) ||
                (l.source === d.text || l.target === d.text)
            );

            let connectionText = "";
            if (connections.length > 0) {
                const connectedWords = connections.map(l => {
                    const sourceText = l.source.text || l.source;
                    const targetText = l.target.text || l.target;
                    const otherWord = sourceText === d.text ? targetText : sourceText;
                    return `${otherWord} (${(l.strength * 100).toFixed(0)}%)`;
                }).join(", ");
                connectionText = `<br><small>Connected to: ${connectedWords}</small>`;
            }

            tooltip.innerHTML = `
                <strong>${d.text}</strong><br>
                Count: ${d.count}${connectionText}
            `;

            // Position tooltip and keep it on screen
            let left = event.pageX + 10;
            let top = event.pageY - 30;

            // First show to get dimensions
            tooltip.classList.add("show");
            const tooltipRect = tooltip.getBoundingClientRect();

            // Adjust if off screen
            if (left + tooltipRect.width > window.innerWidth) {
                left = event.pageX - tooltipRect.width - 10;
            }
            if (top < 0) {
                top = event.pageY + 20;
            }
            if (top + tooltipRect.height > window.innerHeight) {
                top = window.innerHeight - tooltipRect.height - 10;
            }
            if (left < 0) {
                left = 10;
            }

            tooltip.style.left = left + "px";
            tooltip.style.top = top + "px";
        }
        
        function hideTooltip() {
            document.getElementById("tooltip").classList.remove("show");
        }
        
        // Pulse effect for new words
        function addPulseEffect(wordData) {
            mainGroup.append("circle")
                .attr("class", "pulse-ring")
                .attr("cx", wordData.x)
                .attr("cy", wordData.y)
                .attr("r", 0)
                .on("animationend", function() {
                    d3.select(this).remove();
                });
        }
        
        // Update statistics
        function updateStats() {
            document.getElementById("wordCount").textContent = 
                Array.from(words.values()).reduce((sum, w) => sum + w.count, 0);
            document.getElementById("uniqueCount").textContent = words.size;
            document.getElementById("connectionCount").textContent = links.length;
        }
        
        // Keyboard support
        document.getElementById("wordInput").addEventListener("keypress", function(event) {
            if (event.key === "Enter" && !document.getElementById('addButton').disabled) {
                addWord();
            }
        });
        
        // Window resize handling
        window.addEventListener("resize", () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight - 80;
            svg.attr("viewBox", [0, 0, newWidth, newHeight]);
            simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2));
            simulation.force("x", d3.forceX(newWidth / 2).strength(0.05));
            simulation.force("y", d3.forceY(newHeight / 2).strength(0.05));
            simulation.alpha(0.3).restart();
        });
        
        // Sample data for demonstration (optional, can be disabled)
        async function addSampleData() {
            // Disabled for real-time collaborative use
            // Uncomment below to add sample data
            /*
            const sampleWords = [
                "technology", "innovation", "artificial", "intelligence",
                "machine", "learning", "neural", "network",
                "data", "science", "algorithm", "computer",
                "programming", "software", "development", "engineering"
            ];

            for (let i = 0; i < sampleWords.length; i++) {
                await new Promise(resolve => setTimeout(resolve, 300));
                document.getElementById("wordInput").value = sampleWords[i];
                await addWord();
            }
            */
        }

        // Initialize on load
        window.addEventListener("load", () => {
            loadModel();
            initializeColorPicker();
        });
    </script>
</body>
</html>